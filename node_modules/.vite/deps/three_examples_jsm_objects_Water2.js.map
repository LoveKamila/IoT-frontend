{
  "version": 3,
  "sources": ["../../three/examples/jsm/objects/Reflector.js", "../../three/examples/jsm/objects/Refractor.js", "../../three/examples/jsm/objects/Water2.js"],
  "sourcesContent": ["import {\r\n\tColor,\r\n\tMatrix4,\r\n\tMesh,\r\n\tPerspectiveCamera,\r\n\tPlane,\r\n\tShaderMaterial,\r\n\tUniformsUtils,\r\n\tVector3,\r\n\tVector4,\r\n\tWebGLRenderTarget,\r\n\tHalfFloatType,\r\n\tNoToneMapping,\r\n\tLinearEncoding\r\n} from 'three';\r\n\r\nclass Reflector extends Mesh {\r\n\r\n\tconstructor( geometry, options = {} ) {\r\n\r\n\t\tsuper( geometry );\r\n\r\n\t\tthis.isReflector = true;\r\n\r\n\t\tthis.type = 'Reflector';\r\n\t\tthis.camera = new PerspectiveCamera();\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\r\n\t\tconst textureWidth = options.textureWidth || 512;\r\n\t\tconst textureHeight = options.textureHeight || 512;\r\n\t\tconst clipBias = options.clipBias || 0;\r\n\t\tconst shader = options.shader || Reflector.ReflectorShader;\r\n\t\tconst multisample = ( options.multisample !== undefined ) ? options.multisample : 4;\r\n\r\n\t\t//\r\n\r\n\t\tconst reflectorPlane = new Plane();\r\n\t\tconst normal = new Vector3();\r\n\t\tconst reflectorWorldPosition = new Vector3();\r\n\t\tconst cameraWorldPosition = new Vector3();\r\n\t\tconst rotationMatrix = new Matrix4();\r\n\t\tconst lookAtPosition = new Vector3( 0, 0, - 1 );\r\n\t\tconst clipPlane = new Vector4();\r\n\r\n\t\tconst view = new Vector3();\r\n\t\tconst target = new Vector3();\r\n\t\tconst q = new Vector4();\r\n\r\n\t\tconst textureMatrix = new Matrix4();\r\n\t\tconst virtualCamera = this.camera;\r\n\r\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, { samples: multisample, type: HalfFloatType } );\r\n\r\n\t\tconst material = new ShaderMaterial( {\r\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\r\n\t\t\tfragmentShader: shader.fragmentShader,\r\n\t\t\tvertexShader: shader.vertexShader\r\n\t\t} );\r\n\r\n\t\tmaterial.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\r\n\t\tmaterial.uniforms[ 'color' ].value = color;\r\n\t\tmaterial.uniforms[ 'textureMatrix' ].value = textureMatrix;\r\n\r\n\t\tthis.material = material;\r\n\r\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\r\n\r\n\t\t\treflectorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\r\n\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\r\n\r\n\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\r\n\r\n\t\t\tnormal.set( 0, 0, 1 );\r\n\t\t\tnormal.applyMatrix4( rotationMatrix );\r\n\r\n\t\t\tview.subVectors( reflectorWorldPosition, cameraWorldPosition );\r\n\r\n\t\t\t// Avoid rendering when reflector is facing away\r\n\r\n\t\t\tif ( view.dot( normal ) > 0 ) return;\r\n\r\n\t\t\tview.reflect( normal ).negate();\r\n\t\t\tview.add( reflectorWorldPosition );\r\n\r\n\t\t\trotationMatrix.extractRotation( camera.matrixWorld );\r\n\r\n\t\t\tlookAtPosition.set( 0, 0, - 1 );\r\n\t\t\tlookAtPosition.applyMatrix4( rotationMatrix );\r\n\t\t\tlookAtPosition.add( cameraWorldPosition );\r\n\r\n\t\t\ttarget.subVectors( reflectorWorldPosition, lookAtPosition );\r\n\t\t\ttarget.reflect( normal ).negate();\r\n\t\t\ttarget.add( reflectorWorldPosition );\r\n\r\n\t\t\tvirtualCamera.position.copy( view );\r\n\t\t\tvirtualCamera.up.set( 0, 1, 0 );\r\n\t\t\tvirtualCamera.up.applyMatrix4( rotationMatrix );\r\n\t\t\tvirtualCamera.up.reflect( normal );\r\n\t\t\tvirtualCamera.lookAt( target );\r\n\r\n\t\t\tvirtualCamera.far = camera.far; // Used in WebGLBackground\r\n\r\n\t\t\tvirtualCamera.updateMatrixWorld();\r\n\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\r\n\r\n\t\t\t// Update the texture matrix\r\n\t\t\ttextureMatrix.set(\r\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t\t);\r\n\t\t\ttextureMatrix.multiply( virtualCamera.projectionMatrix );\r\n\t\t\ttextureMatrix.multiply( virtualCamera.matrixWorldInverse );\r\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\r\n\r\n\t\t\t// Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html\r\n\t\t\t// Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf\r\n\t\t\treflectorPlane.setFromNormalAndCoplanarPoint( normal, reflectorWorldPosition );\r\n\t\t\treflectorPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\r\n\r\n\t\t\tclipPlane.set( reflectorPlane.normal.x, reflectorPlane.normal.y, reflectorPlane.normal.z, reflectorPlane.constant );\r\n\r\n\t\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\r\n\r\n\t\t\tq.x = ( Math.sign( clipPlane.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\r\n\t\t\tq.y = ( Math.sign( clipPlane.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\r\n\t\t\tq.z = - 1.0;\r\n\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\r\n\r\n\t\t\t// Calculate the scaled plane vector\r\n\t\t\tclipPlane.multiplyScalar( 2.0 / clipPlane.dot( q ) );\r\n\r\n\t\t\t// Replacing the third row of the projection matrix\r\n\t\t\tprojectionMatrix.elements[ 2 ] = clipPlane.x;\r\n\t\t\tprojectionMatrix.elements[ 6 ] = clipPlane.y;\r\n\t\t\tprojectionMatrix.elements[ 10 ] = clipPlane.z + 1.0 - clipBias;\r\n\t\t\tprojectionMatrix.elements[ 14 ] = clipPlane.w;\r\n\r\n\t\t\t// Render\r\n\t\t\tscope.visible = false;\r\n\r\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\r\n\r\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\r\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\r\n\t\t\tconst currentOutputEncoding = renderer.outputEncoding;\r\n\t\t\tconst currentToneMapping = renderer.toneMapping;\r\n\r\n\t\t\trenderer.xr.enabled = false; // Avoid camera modification\r\n\t\t\trenderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows\r\n\t\t\trenderer.outputEncoding = LinearEncoding;\r\n\t\t\trenderer.toneMapping = NoToneMapping;\r\n\r\n\t\t\trenderer.setRenderTarget( renderTarget );\r\n\r\n\t\t\trenderer.state.buffers.depth.setMask( true ); // make sure the depth buffer is writable so it can be properly cleared, see #18897\r\n\r\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\r\n\t\t\trenderer.render( scene, virtualCamera );\r\n\r\n\t\t\trenderer.xr.enabled = currentXrEnabled;\r\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\r\n\t\t\trenderer.outputEncoding = currentOutputEncoding;\r\n\t\t\trenderer.toneMapping = currentToneMapping;\r\n\r\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\r\n\r\n\t\t\t// Restore viewport\r\n\r\n\t\t\tconst viewport = camera.viewport;\r\n\r\n\t\t\tif ( viewport !== undefined ) {\r\n\r\n\t\t\t\trenderer.state.viewport( viewport );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscope.visible = true;\r\n\r\n\t\t};\r\n\r\n\t\tthis.getRenderTarget = function () {\r\n\r\n\t\t\treturn renderTarget;\r\n\r\n\t\t};\r\n\r\n\t\tthis.dispose = function () {\r\n\r\n\t\t\trenderTarget.dispose();\r\n\t\t\tscope.material.dispose();\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n\r\nReflector.ReflectorShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t'color': {\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'tDiffuse': {\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'textureMatrix': {\r\n\t\t\tvalue: null\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\t\tuniform mat4 textureMatrix;\r\n\t\tvarying vec4 vUv;\r\n\r\n\t\t#include <common>\r\n\t\t#include <logdepthbuf_pars_vertex>\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\t#include <logdepthbuf_vertex>\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\t\tuniform vec3 color;\r\n\t\tuniform sampler2D tDiffuse;\r\n\t\tvarying vec4 vUv;\r\n\r\n\t\t#include <logdepthbuf_pars_fragment>\r\n\r\n\t\tfloat blendOverlay( float base, float blend ) {\r\n\r\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\r\n\r\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\r\n\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#include <logdepthbuf_fragment>\r\n\r\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\r\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\r\n\r\n\t\t\t#include <tonemapping_fragment>\r\n\t\t\t#include <encodings_fragment>\r\n\r\n\t\t}`\r\n};\r\n\r\nexport { Reflector };\r\n", "import {\r\n\tColor,\r\n\tMatrix4,\r\n\tMesh,\r\n\tPerspectiveCamera,\r\n\tPlane,\r\n\tQuaternion,\r\n\tShaderMaterial,\r\n\tUniformsUtils,\r\n\tVector3,\r\n\tVector4,\r\n\tWebGLRenderTarget,\r\n\tLinearEncoding,\r\n\tNoToneMapping,\r\n\tHalfFloatType\r\n} from 'three';\r\n\r\nclass Refractor extends Mesh {\r\n\r\n\tconstructor( geometry, options = {} ) {\r\n\r\n\t\tsuper( geometry );\r\n\r\n\t\tthis.isRefractor = true;\r\n\r\n\t\tthis.type = 'Refractor';\r\n\t\tthis.camera = new PerspectiveCamera();\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0x7F7F7F );\r\n\t\tconst textureWidth = options.textureWidth || 512;\r\n\t\tconst textureHeight = options.textureHeight || 512;\r\n\t\tconst clipBias = options.clipBias || 0;\r\n\t\tconst shader = options.shader || Refractor.RefractorShader;\r\n\t\tconst multisample = ( options.multisample !== undefined ) ? options.multisample : 4;\r\n\r\n\t\t//\r\n\r\n\t\tconst virtualCamera = this.camera;\r\n\t\tvirtualCamera.matrixAutoUpdate = false;\r\n\t\tvirtualCamera.userData.refractor = true;\r\n\r\n\t\t//\r\n\r\n\t\tconst refractorPlane = new Plane();\r\n\t\tconst textureMatrix = new Matrix4();\r\n\r\n\t\t// render target\r\n\r\n\t\tconst renderTarget = new WebGLRenderTarget( textureWidth, textureHeight, { samples: multisample, type: HalfFloatType } );\r\n\r\n\t\t// material\r\n\r\n\t\tthis.material = new ShaderMaterial( {\r\n\t\t\tuniforms: UniformsUtils.clone( shader.uniforms ),\r\n\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\tfragmentShader: shader.fragmentShader,\r\n\t\t\ttransparent: true // ensures, refractors are drawn from farthest to closest\r\n\t\t} );\r\n\r\n\t\tthis.material.uniforms[ 'color' ].value = color;\r\n\t\tthis.material.uniforms[ 'tDiffuse' ].value = renderTarget.texture;\r\n\t\tthis.material.uniforms[ 'textureMatrix' ].value = textureMatrix;\r\n\r\n\t\t// functions\r\n\r\n\t\tconst visible = ( function () {\r\n\r\n\t\t\tconst refractorWorldPosition = new Vector3();\r\n\t\t\tconst cameraWorldPosition = new Vector3();\r\n\t\t\tconst rotationMatrix = new Matrix4();\r\n\r\n\t\t\tconst view = new Vector3();\r\n\t\t\tconst normal = new Vector3();\r\n\r\n\t\t\treturn function visible( camera ) {\r\n\r\n\t\t\t\trefractorWorldPosition.setFromMatrixPosition( scope.matrixWorld );\r\n\t\t\t\tcameraWorldPosition.setFromMatrixPosition( camera.matrixWorld );\r\n\r\n\t\t\t\tview.subVectors( refractorWorldPosition, cameraWorldPosition );\r\n\r\n\t\t\t\trotationMatrix.extractRotation( scope.matrixWorld );\r\n\r\n\t\t\t\tnormal.set( 0, 0, 1 );\r\n\t\t\t\tnormal.applyMatrix4( rotationMatrix );\r\n\r\n\t\t\t\treturn view.dot( normal ) < 0;\r\n\r\n\t\t\t};\r\n\r\n\t\t} )();\r\n\r\n\t\tconst updateRefractorPlane = ( function () {\r\n\r\n\t\t\tconst normal = new Vector3();\r\n\t\t\tconst position = new Vector3();\r\n\t\t\tconst quaternion = new Quaternion();\r\n\t\t\tconst scale = new Vector3();\r\n\r\n\t\t\treturn function updateRefractorPlane() {\r\n\r\n\t\t\t\tscope.matrixWorld.decompose( position, quaternion, scale );\r\n\t\t\t\tnormal.set( 0, 0, 1 ).applyQuaternion( quaternion ).normalize();\r\n\r\n\t\t\t\t// flip the normal because we want to cull everything above the plane\r\n\r\n\t\t\t\tnormal.negate();\r\n\r\n\t\t\t\trefractorPlane.setFromNormalAndCoplanarPoint( normal, position );\r\n\r\n\t\t\t};\r\n\r\n\t\t} )();\r\n\r\n\t\tconst updateVirtualCamera = ( function () {\r\n\r\n\t\t\tconst clipPlane = new Plane();\r\n\t\t\tconst clipVector = new Vector4();\r\n\t\t\tconst q = new Vector4();\r\n\r\n\t\t\treturn function updateVirtualCamera( camera ) {\r\n\r\n\t\t\t\tvirtualCamera.matrixWorld.copy( camera.matrixWorld );\r\n\t\t\t\tvirtualCamera.matrixWorldInverse.copy( virtualCamera.matrixWorld ).invert();\r\n\t\t\t\tvirtualCamera.projectionMatrix.copy( camera.projectionMatrix );\r\n\t\t\t\tvirtualCamera.far = camera.far; // used in WebGLBackground\r\n\r\n\t\t\t\t// The following code creates an oblique view frustum for clipping.\r\n\t\t\t\t// see: Lengyel, Eric. “Oblique View Frustum Depth Projection and Clipping”.\r\n\t\t\t\t// Journal of Game Development, Vol. 1, No. 2 (2005), Charles River Media, pp. 5–16\r\n\r\n\t\t\t\tclipPlane.copy( refractorPlane );\r\n\t\t\t\tclipPlane.applyMatrix4( virtualCamera.matrixWorldInverse );\r\n\r\n\t\t\t\tclipVector.set( clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.constant );\r\n\r\n\t\t\t\t// calculate the clip-space corner point opposite the clipping plane and\r\n\t\t\t\t// transform it into camera space by multiplying it by the inverse of the projection matrix\r\n\r\n\t\t\t\tconst projectionMatrix = virtualCamera.projectionMatrix;\r\n\r\n\t\t\t\tq.x = ( Math.sign( clipVector.x ) + projectionMatrix.elements[ 8 ] ) / projectionMatrix.elements[ 0 ];\r\n\t\t\t\tq.y = ( Math.sign( clipVector.y ) + projectionMatrix.elements[ 9 ] ) / projectionMatrix.elements[ 5 ];\r\n\t\t\t\tq.z = - 1.0;\r\n\t\t\t\tq.w = ( 1.0 + projectionMatrix.elements[ 10 ] ) / projectionMatrix.elements[ 14 ];\r\n\r\n\t\t\t\t// calculate the scaled plane vector\r\n\r\n\t\t\t\tclipVector.multiplyScalar( 2.0 / clipVector.dot( q ) );\r\n\r\n\t\t\t\t// replacing the third row of the projection matrix\r\n\r\n\t\t\t\tprojectionMatrix.elements[ 2 ] = clipVector.x;\r\n\t\t\t\tprojectionMatrix.elements[ 6 ] = clipVector.y;\r\n\t\t\t\tprojectionMatrix.elements[ 10 ] = clipVector.z + 1.0 - clipBias;\r\n\t\t\t\tprojectionMatrix.elements[ 14 ] = clipVector.w;\r\n\r\n\t\t\t};\r\n\r\n\t\t} )();\r\n\r\n\t\t// This will update the texture matrix that is used for projective texture mapping in the shader.\r\n\t\t// see: http://developer.download.nvidia.com/assets/gamedev/docs/projective_texture_mapping.pdf\r\n\r\n\t\tfunction updateTextureMatrix( camera ) {\r\n\r\n\t\t\t// this matrix does range mapping to [ 0, 1 ]\r\n\r\n\t\t\ttextureMatrix.set(\r\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t\t);\r\n\r\n\t\t\t// we use \"Object Linear Texgen\", so we need to multiply the texture matrix T\r\n\t\t\t// (matrix above) with the projection and view matrix of the virtual camera\r\n\t\t\t// and the model matrix of the refractor\r\n\r\n\t\t\ttextureMatrix.multiply( camera.projectionMatrix );\r\n\t\t\ttextureMatrix.multiply( camera.matrixWorldInverse );\r\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tfunction render( renderer, scene, camera ) {\r\n\r\n\t\t\tscope.visible = false;\r\n\r\n\t\t\tconst currentRenderTarget = renderer.getRenderTarget();\r\n\t\t\tconst currentXrEnabled = renderer.xr.enabled;\r\n\t\t\tconst currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;\r\n\t\t\tconst currentOutputEncoding = renderer.outputEncoding;\r\n\t\t\tconst currentToneMapping = renderer.toneMapping;\r\n\r\n\t\t\trenderer.xr.enabled = false; // avoid camera modification\r\n\t\t\trenderer.shadowMap.autoUpdate = false; // avoid re-computing shadows\r\n\t\t\trenderer.outputEncoding = LinearEncoding;\r\n\t\t\trenderer.toneMapping = NoToneMapping;\r\n\r\n\t\t\trenderer.setRenderTarget( renderTarget );\r\n\t\t\tif ( renderer.autoClear === false ) renderer.clear();\r\n\t\t\trenderer.render( scene, virtualCamera );\r\n\r\n\t\t\trenderer.xr.enabled = currentXrEnabled;\r\n\t\t\trenderer.shadowMap.autoUpdate = currentShadowAutoUpdate;\r\n\t\t\trenderer.outputEncoding = currentOutputEncoding;\r\n\t\t\trenderer.toneMapping = currentToneMapping;\r\n\t\t\trenderer.setRenderTarget( currentRenderTarget );\r\n\r\n\t\t\t// restore viewport\r\n\r\n\t\t\tconst viewport = camera.viewport;\r\n\r\n\t\t\tif ( viewport !== undefined ) {\r\n\r\n\t\t\t\trenderer.state.viewport( viewport );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tscope.visible = true;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\r\n\r\n\t\t\t// ensure refractors are rendered only once per frame\r\n\r\n\t\t\tif ( camera.userData.refractor === true ) return;\r\n\r\n\t\t\t// avoid rendering when the refractor is viewed from behind\r\n\r\n\t\t\tif ( ! visible( camera ) === true ) return;\r\n\r\n\t\t\t// update\r\n\r\n\t\t\tupdateRefractorPlane();\r\n\r\n\t\t\tupdateTextureMatrix( camera );\r\n\r\n\t\t\tupdateVirtualCamera( camera );\r\n\r\n\t\t\trender( renderer, scene, camera );\r\n\r\n\t\t};\r\n\r\n\t\tthis.getRenderTarget = function () {\r\n\r\n\t\t\treturn renderTarget;\r\n\r\n\t\t};\r\n\r\n\t\tthis.dispose = function () {\r\n\r\n\t\t\trenderTarget.dispose();\r\n\t\t\tscope.material.dispose();\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n\r\nRefractor.RefractorShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t'color': {\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'tDiffuse': {\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'textureMatrix': {\r\n\t\t\tvalue: null\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\tuniform mat4 textureMatrix;\r\n\r\n\t\tvarying vec4 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\tuniform vec3 color;\r\n\t\tuniform sampler2D tDiffuse;\r\n\r\n\t\tvarying vec4 vUv;\r\n\r\n\t\tfloat blendOverlay( float base, float blend ) {\r\n\r\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\r\n\r\n\t\t}\r\n\r\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\r\n\r\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\r\n\r\n\t\t}\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\r\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\r\n\r\n\t\t\t#include <tonemapping_fragment>\r\n\t\t\t#include <encodings_fragment>\r\n\r\n\t\t}`\r\n\r\n};\r\n\r\nexport { Refractor };\r\n", "import {\r\n\tClock,\r\n\tColor,\r\n\tMatrix4,\r\n\tMesh,\r\n\tRepeatWrapping,\r\n\tShaderMaterial,\r\n\tTextureLoader,\r\n\tUniformsLib,\r\n\tUniformsUtils,\r\n\tVector2,\r\n\tVector4\r\n} from 'three';\r\nimport { Reflector } from '../objects/Reflector.js';\r\nimport { Refractor } from '../objects/Refractor.js';\r\n\r\n/**\r\n * References:\r\n *\thttps://alex.vlachos.com/graphics/Vlachos-SIGGRAPH10-WaterFlow.pdf\r\n *\thttp://graphicsrunner.blogspot.de/2010/08/water-using-flow-maps.html\r\n *\r\n */\r\n\r\nclass Water extends Mesh {\r\n\r\n\tconstructor( geometry, options = {} ) {\r\n\r\n\t\tsuper( geometry );\r\n\r\n\t\tthis.isWater = true;\r\n\r\n\t\tthis.type = 'Water';\r\n\r\n\t\tconst scope = this;\r\n\r\n\t\tconst color = ( options.color !== undefined ) ? new Color( options.color ) : new Color( 0xFFFFFF );\r\n\t\tconst textureWidth = options.textureWidth || 512;\r\n\t\tconst textureHeight = options.textureHeight || 512;\r\n\t\tconst clipBias = options.clipBias || 0;\r\n\t\tconst flowDirection = options.flowDirection || new Vector2( 1, 0 );\r\n\t\tconst flowSpeed = options.flowSpeed || 0.03;\r\n\t\tconst reflectivity = options.reflectivity || 0.02;\r\n\t\tconst scale = options.scale || 1;\r\n\t\tconst shader = options.shader || Water.WaterShader;\r\n\r\n\t\tconst textureLoader = new TextureLoader();\r\n\r\n\t\tconst flowMap = options.flowMap || undefined;\r\n\t\tconst normalMap0 = options.normalMap0 || textureLoader.load( 'textures/water/Water_1_M_Normal.jpg' );\r\n\t\tconst normalMap1 = options.normalMap1 || textureLoader.load( 'textures/water/Water_2_M_Normal.jpg' );\r\n\r\n\t\tconst cycle = 0.15; // a cycle of a flow map phase\r\n\t\tconst halfCycle = cycle * 0.5;\r\n\t\tconst textureMatrix = new Matrix4();\r\n\t\tconst clock = new Clock();\r\n\r\n\t\t// internal components\r\n\r\n\t\tif ( Reflector === undefined ) {\r\n\r\n\t\t\tconsole.error( 'THREE.Water: Required component Reflector not found.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( Refractor === undefined ) {\r\n\r\n\t\t\tconsole.error( 'THREE.Water: Required component Refractor not found.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tconst reflector = new Reflector( geometry, {\r\n\t\t\ttextureWidth: textureWidth,\r\n\t\t\ttextureHeight: textureHeight,\r\n\t\t\tclipBias: clipBias\r\n\t\t} );\r\n\r\n\t\tconst refractor = new Refractor( geometry, {\r\n\t\t\ttextureWidth: textureWidth,\r\n\t\t\ttextureHeight: textureHeight,\r\n\t\t\tclipBias: clipBias\r\n\t\t} );\r\n\r\n\t\treflector.matrixAutoUpdate = false;\r\n\t\trefractor.matrixAutoUpdate = false;\r\n\r\n\t\t// material\r\n\r\n\t\tthis.material = new ShaderMaterial( {\r\n\t\t\tuniforms: UniformsUtils.merge( [\r\n\t\t\t\tUniformsLib[ 'fog' ],\r\n\t\t\t\tshader.uniforms\r\n\t\t\t] ),\r\n\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\tfragmentShader: shader.fragmentShader,\r\n\t\t\ttransparent: true,\r\n\t\t\tfog: true\r\n\t\t} );\r\n\r\n\t\tif ( flowMap !== undefined ) {\r\n\r\n\t\t\tthis.material.defines.USE_FLOWMAP = '';\r\n\t\t\tthis.material.uniforms[ 'tFlowMap' ] = {\r\n\t\t\t\ttype: 't',\r\n\t\t\t\tvalue: flowMap\r\n\t\t\t};\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.material.uniforms[ 'flowDirection' ] = {\r\n\t\t\t\ttype: 'v2',\r\n\t\t\t\tvalue: flowDirection\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t// maps\r\n\r\n\t\tnormalMap0.wrapS = normalMap0.wrapT = RepeatWrapping;\r\n\t\tnormalMap1.wrapS = normalMap1.wrapT = RepeatWrapping;\r\n\r\n\t\tthis.material.uniforms[ 'tReflectionMap' ].value = reflector.getRenderTarget().texture;\r\n\t\tthis.material.uniforms[ 'tRefractionMap' ].value = refractor.getRenderTarget().texture;\r\n\t\tthis.material.uniforms[ 'tNormalMap0' ].value = normalMap0;\r\n\t\tthis.material.uniforms[ 'tNormalMap1' ].value = normalMap1;\r\n\r\n\t\t// water\r\n\r\n\t\tthis.material.uniforms[ 'color' ].value = color;\r\n\t\tthis.material.uniforms[ 'reflectivity' ].value = reflectivity;\r\n\t\tthis.material.uniforms[ 'textureMatrix' ].value = textureMatrix;\r\n\r\n\t\t// inital values\r\n\r\n\t\tthis.material.uniforms[ 'config' ].value.x = 0; // flowMapOffset0\r\n\t\tthis.material.uniforms[ 'config' ].value.y = halfCycle; // flowMapOffset1\r\n\t\tthis.material.uniforms[ 'config' ].value.z = halfCycle; // halfCycle\r\n\t\tthis.material.uniforms[ 'config' ].value.w = scale; // scale\r\n\r\n\t\t// functions\r\n\r\n\t\tfunction updateTextureMatrix( camera ) {\r\n\r\n\t\t\ttextureMatrix.set(\r\n\t\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t\t);\r\n\r\n\t\t\ttextureMatrix.multiply( camera.projectionMatrix );\r\n\t\t\ttextureMatrix.multiply( camera.matrixWorldInverse );\r\n\t\t\ttextureMatrix.multiply( scope.matrixWorld );\r\n\r\n\t\t}\r\n\r\n\t\tfunction updateFlow() {\r\n\r\n\t\t\tconst delta = clock.getDelta();\r\n\t\t\tconst config = scope.material.uniforms[ 'config' ];\r\n\r\n\t\t\tconfig.value.x += flowSpeed * delta; // flowMapOffset0\r\n\t\t\tconfig.value.y = config.value.x + halfCycle; // flowMapOffset1\r\n\r\n\t\t\t// Important: The distance between offsets should be always the value of \"halfCycle\".\r\n\t\t\t// Moreover, both offsets should be in the range of [ 0, cycle ].\r\n\t\t\t// This approach ensures a smooth water flow and avoids \"reset\" effects.\r\n\r\n\t\t\tif ( config.value.x >= cycle ) {\r\n\r\n\t\t\t\tconfig.value.x = 0;\r\n\t\t\t\tconfig.value.y = halfCycle;\r\n\r\n\t\t\t} else if ( config.value.y >= cycle ) {\r\n\r\n\t\t\t\tconfig.value.y = config.value.y - cycle;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tthis.onBeforeRender = function ( renderer, scene, camera ) {\r\n\r\n\t\t\tupdateTextureMatrix( camera );\r\n\t\t\tupdateFlow();\r\n\r\n\t\t\tscope.visible = false;\r\n\r\n\t\t\treflector.matrixWorld.copy( scope.matrixWorld );\r\n\t\t\trefractor.matrixWorld.copy( scope.matrixWorld );\r\n\r\n\t\t\treflector.onBeforeRender( renderer, scene, camera );\r\n\t\t\trefractor.onBeforeRender( renderer, scene, camera );\r\n\r\n\t\t\tscope.visible = true;\r\n\r\n\t\t};\r\n\r\n\t}\r\n\r\n}\r\n\r\nWater.WaterShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t'color': {\r\n\t\t\ttype: 'c',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'reflectivity': {\r\n\t\t\ttype: 'f',\r\n\t\t\tvalue: 0\r\n\t\t},\r\n\r\n\t\t'tReflectionMap': {\r\n\t\t\ttype: 't',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'tRefractionMap': {\r\n\t\t\ttype: 't',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'tNormalMap0': {\r\n\t\t\ttype: 't',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'tNormalMap1': {\r\n\t\t\ttype: 't',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'textureMatrix': {\r\n\t\t\ttype: 'm4',\r\n\t\t\tvalue: null\r\n\t\t},\r\n\r\n\t\t'config': {\r\n\t\t\ttype: 'v4',\r\n\t\t\tvalue: new Vector4()\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\t#include <common>\r\n\t\t#include <fog_pars_vertex>\r\n\t\t#include <logdepthbuf_pars_vertex>\r\n\r\n\t\tuniform mat4 textureMatrix;\r\n\r\n\t\tvarying vec4 vCoord;\r\n\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 vToEye;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = uv;\r\n\t\t\tvCoord = textureMatrix * vec4( position, 1.0 );\r\n\r\n\t\t\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\r\n\t\t\tvToEye = cameraPosition - worldPosition.xyz;\r\n\r\n\t\t\tvec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex\r\n\t\t\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t\t\t#include <logdepthbuf_vertex>\r\n\t\t\t#include <fog_vertex>\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\t#include <common>\r\n\t\t#include <fog_pars_fragment>\r\n\t\t#include <logdepthbuf_pars_fragment>\r\n\r\n\t\tuniform sampler2D tReflectionMap;\r\n\t\tuniform sampler2D tRefractionMap;\r\n\t\tuniform sampler2D tNormalMap0;\r\n\t\tuniform sampler2D tNormalMap1;\r\n\r\n\t\t#ifdef USE_FLOWMAP\r\n\t\t\tuniform sampler2D tFlowMap;\r\n\t\t#else\r\n\t\t\tuniform vec2 flowDirection;\r\n\t\t#endif\r\n\r\n\t\tuniform vec3 color;\r\n\t\tuniform float reflectivity;\r\n\t\tuniform vec4 config;\r\n\r\n\t\tvarying vec4 vCoord;\r\n\t\tvarying vec2 vUv;\r\n\t\tvarying vec3 vToEye;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\t#include <logdepthbuf_fragment>\r\n\r\n\t\t\tfloat flowMapOffset0 = config.x;\r\n\t\t\tfloat flowMapOffset1 = config.y;\r\n\t\t\tfloat halfCycle = config.z;\r\n\t\t\tfloat scale = config.w;\r\n\r\n\t\t\tvec3 toEye = normalize( vToEye );\r\n\r\n\t\t\t// determine flow direction\r\n\t\t\tvec2 flow;\r\n\t\t\t#ifdef USE_FLOWMAP\r\n\t\t\t\tflow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;\r\n\t\t\t#else\r\n\t\t\t\tflow = flowDirection;\r\n\t\t\t#endif\r\n\t\t\tflow.x *= - 1.0;\r\n\r\n\t\t\t// sample normal maps (distort uvs with flowdata)\r\n\t\t\tvec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );\r\n\t\t\tvec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );\r\n\r\n\t\t\t// linear interpolate to get the final normal color\r\n\t\t\tfloat flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;\r\n\t\t\tvec4 normalColor = mix( normalColor0, normalColor1, flowLerp );\r\n\r\n\t\t\t// calculate normal vector\r\n\t\t\tvec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\r\n\r\n\t\t\t// calculate the fresnel term to blend reflection and refraction maps\r\n\t\t\tfloat theta = max( dot( toEye, normal ), 0.0 );\r\n\t\t\tfloat reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );\r\n\r\n\t\t\t// calculate final uv coords\r\n\t\t\tvec3 coord = vCoord.xyz / vCoord.w;\r\n\t\t\tvec2 uv = coord.xy + coord.z * normal.xz * 0.05;\r\n\r\n\t\t\tvec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );\r\n\t\t\tvec4 refractColor = texture2D( tRefractionMap, uv );\r\n\r\n\t\t\t// multiply water color with the mix of both textures\r\n\t\t\tgl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );\r\n\r\n\t\t\t#include <tonemapping_fragment>\r\n\t\t\t#include <encodings_fragment>\r\n\t\t\t#include <fog_fragment>\r\n\r\n\t\t}`\r\n\r\n};\r\n\r\nexport { Water };\r\n"],
  "mappings": "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",
  "names": ["visible", "updateRefractorPlane", "updateVirtualCamera"]
}
