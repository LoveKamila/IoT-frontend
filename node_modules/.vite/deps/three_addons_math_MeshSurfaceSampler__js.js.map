{
  "version": 3,
  "sources": ["../../three/examples/jsm/math/MeshSurfaceSampler.js"],
  "sourcesContent": ["import {\r\n\tTriangle,\r\n\tVector3\r\n} from 'three';\r\n\r\n/**\r\n * Utility class for sampling weighted random points on the surface of a mesh.\r\n *\r\n * Building the sampler is a one-time O(n) operation. Once built, any number of\r\n * random samples may be selected in O(logn) time. Memory usage is O(n).\r\n *\r\n * References:\r\n * - http://www.joesfer.com/?p=84\r\n * - https://stackoverflow.com/a/4322940/1314762\r\n */\r\n\r\nconst _face = new Triangle();\r\nconst _color = new Vector3();\r\n\r\nclass MeshSurfaceSampler {\r\n\r\n\tconstructor( mesh ) {\r\n\r\n\t\tlet geometry = mesh.geometry;\r\n\r\n\t\tif ( geometry.index ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.MeshSurfaceSampler: Converting geometry to non-indexed BufferGeometry.' );\r\n\r\n\t\t\tgeometry = geometry.toNonIndexed();\r\n\r\n\t\t}\r\n\r\n\t\tthis.geometry = geometry;\r\n\t\tthis.randomFunction = Math.random;\r\n\r\n\t\tthis.positionAttribute = this.geometry.getAttribute( 'position' );\r\n\t\tthis.colorAttribute = this.geometry.getAttribute( 'color' );\r\n\t\tthis.weightAttribute = null;\r\n\r\n\t\tthis.distribution = null;\r\n\r\n\t}\r\n\r\n\tsetWeightAttribute( name ) {\r\n\r\n\t\tthis.weightAttribute = name ? this.geometry.getAttribute( name ) : null;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tbuild() {\r\n\r\n\t\tconst positionAttribute = this.positionAttribute;\r\n\t\tconst weightAttribute = this.weightAttribute;\r\n\r\n\t\tconst faceWeights = new Float32Array( positionAttribute.count / 3 );\r\n\r\n\t\t// Accumulate weights for each mesh face.\r\n\r\n\t\tfor ( let i = 0; i < positionAttribute.count; i += 3 ) {\r\n\r\n\t\t\tlet faceWeight = 1;\r\n\r\n\t\t\tif ( weightAttribute ) {\r\n\r\n\t\t\t\tfaceWeight = weightAttribute.getX( i )\r\n\t\t\t\t\t+ weightAttribute.getX( i + 1 )\r\n\t\t\t\t\t+ weightAttribute.getX( i + 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_face.a.fromBufferAttribute( positionAttribute, i );\r\n\t\t\t_face.b.fromBufferAttribute( positionAttribute, i + 1 );\r\n\t\t\t_face.c.fromBufferAttribute( positionAttribute, i + 2 );\r\n\t\t\tfaceWeight *= _face.getArea();\r\n\r\n\t\t\tfaceWeights[ i / 3 ] = faceWeight;\r\n\r\n\t\t}\r\n\r\n\t\t// Store cumulative total face weights in an array, where weight index\r\n\t\t// corresponds to face index.\r\n\r\n\t\tthis.distribution = new Float32Array( positionAttribute.count / 3 );\r\n\r\n\t\tlet cumulativeTotal = 0;\r\n\r\n\t\tfor ( let i = 0; i < faceWeights.length; i ++ ) {\r\n\r\n\t\t\tcumulativeTotal += faceWeights[ i ];\r\n\r\n\t\t\tthis.distribution[ i ] = cumulativeTotal;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsetRandomGenerator( randomFunction ) {\r\n\r\n\t\tthis.randomFunction = randomFunction;\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n\tsample( targetPosition, targetNormal, targetColor ) {\r\n\r\n\t\tconst cumulativeTotal = this.distribution[ this.distribution.length - 1 ];\r\n\r\n\t\tconst faceIndex = this.binarySearch( this.randomFunction() * cumulativeTotal );\r\n\r\n\t\treturn this.sampleFace( faceIndex, targetPosition, targetNormal, targetColor );\r\n\r\n\t}\r\n\r\n\tbinarySearch( x ) {\r\n\r\n\t\tconst dist = this.distribution;\r\n\t\tlet start = 0;\r\n\t\tlet end = dist.length - 1;\r\n\r\n\t\tlet index = - 1;\r\n\r\n\t\twhile ( start <= end ) {\r\n\r\n\t\t\tconst mid = Math.ceil( ( start + end ) / 2 );\r\n\r\n\t\t\tif ( mid === 0 || dist[ mid - 1 ] <= x && dist[ mid ] > x ) {\r\n\r\n\t\t\t\tindex = mid;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t} else if ( x < dist[ mid ] ) {\r\n\r\n\t\t\t\tend = mid - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstart = mid + 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn index;\r\n\r\n\t}\r\n\r\n\tsampleFace( faceIndex, targetPosition, targetNormal, targetColor ) {\r\n\r\n\t\tlet u = this.randomFunction();\r\n\t\tlet v = this.randomFunction();\r\n\r\n\t\tif ( u + v > 1 ) {\r\n\r\n\t\t\tu = 1 - u;\r\n\t\t\tv = 1 - v;\r\n\r\n\t\t}\r\n\r\n\t\t_face.a.fromBufferAttribute( this.positionAttribute, faceIndex * 3 );\r\n\t\t_face.b.fromBufferAttribute( this.positionAttribute, faceIndex * 3 + 1 );\r\n\t\t_face.c.fromBufferAttribute( this.positionAttribute, faceIndex * 3 + 2 );\r\n\r\n\t\ttargetPosition\r\n\t\t\t.set( 0, 0, 0 )\r\n\t\t\t.addScaledVector( _face.a, u )\r\n\t\t\t.addScaledVector( _face.b, v )\r\n\t\t\t.addScaledVector( _face.c, 1 - ( u + v ) );\r\n\r\n\t\tif ( targetNormal !== undefined ) {\r\n\r\n\t\t\t_face.getNormal( targetNormal );\r\n\r\n\t\t}\r\n\r\n\t\tif ( targetColor !== undefined && this.colorAttribute !== undefined ) {\r\n\r\n\t\t\t_face.a.fromBufferAttribute( this.colorAttribute, faceIndex * 3 );\r\n\t\t\t_face.b.fromBufferAttribute( this.colorAttribute, faceIndex * 3 + 1 );\r\n\t\t\t_face.c.fromBufferAttribute( this.colorAttribute, faceIndex * 3 + 2 );\r\n\r\n\t\t\t_color\r\n\t\t\t\t.set( 0, 0, 0 )\r\n\t\t\t\t.addScaledVector( _face.a, u )\r\n\t\t\t\t.addScaledVector( _face.b, v )\r\n\t\t\t\t.addScaledVector( _face.c, 1 - ( u + v ) );\r\n\r\n\t\t\ttargetColor.r = _color.x;\r\n\t\t\ttargetColor.g = _color.y;\r\n\t\t\ttargetColor.b = _color.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport { MeshSurfaceSampler };\r\n"],
  "mappings": "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",
  "names": []
}
